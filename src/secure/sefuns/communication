/// @addtogroup sefun
/// @{
/// @file communication
/// @brief sefuns for telling someone(s) somewhere something
///
/// these efuns are wrapper for efun::message
/// @author Gwenhwyvar
/// @version 0.0.0
/// @date 2016-01-29

// --------------------------------------------------------------------------
/// @brief printf 
/// wrapper using sefun::write [MSG_CLASS_SYSTEM]
/// @Param format
/// @Param args
/// @Returns 
// --------------------------------------------------------------------------
public void printf(string format, mixed *args...)
{
    write(sprintf(format, args...));
}

// public void say(string msg, mixed *exclude, int msg_class = MSGCLASS_SYSTEM);
// public void shout(string msg, int msg_class = MSGCLASS_SYSTEM);
// public void tell_object(object ob, string msg, int msg_class = MSGCLASS_SYSTEM);
// public void tell_room(mixed ob, string msg, object *exclude, int msg_class = MSGCLASS_SYSTEM);

// --------------------------------------------------------------------------
/// @brief write 
///
/// override for efun::write using efun::message instead
/// optional parameter msg_class added
/// @Param msg
/// @Param msg_class
/// @Returns 
// --------------------------------------------------------------------------
public void write(string msg, int msg_class = MSGCLASS_SYSTEM|MSG_WRAP)
{
    object tp = TP();

    // system messages are always wrapped...
    if(msg_class == MSGCLASS_SYSTEM)
        msg_class |= MSG_WRAP;

    // without this_player and for master we want the efun write
    if(!tp || (TO() == master()))
        efun::write(msg);
    // otherwise we switch to message system
    else
        message(msg_class, msg, ({ tp }), ({}));
}
///  @}
